---
title: "GCalignR Step by Step"
author: "Meinolf Ottensmann, Martin A. Stoffel, Joseph Hoffman"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: bibliography.bib
vignette: >
    %\VignetteIndexEntry{GCalignR step by step}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE}
library(knitr)
knitr::opts_chunk$set(collapse = TRUE, comment = "#>", cache = FALSE,
    fig.width = 6, fig.height = 6) # warning = FALSE
```

## Introduction

Metabolomics approaches such as Gas-Chromatography-Mass-Spectrometry (GC-MS) are increasingly used
by biologists to unravel the chemical basis of animal olfactory communication. For the detection
of broader patterns in chemical samples most researchers use an untargeted approach and
analyse the whole spectrum of chemicals rather than targeting specific compounds. However, 
chromatography data across multiple samples are not directly comparable as the retention times of peaks
vary across samples due to subtle, random and often unavoidable variation of the GC-MS machine parameters [@pierce2005classification]. For studies interested in chemical patterns across samples it therefore 
becomes essential to account for these retention time drifts by using an appropriate alignment method.

Despite the existence of automated alignment algorithms [e.g. @smith2006xcms; @stein1999integrated; @robinson2007dynamic], most researchers in the relatively young fields of mammalian and avian chemical communication align chromatograms manually
[@charpentier2008smelling; @setchell2010odour; @caspers2011scents; @leclaire2012semiochemical; @theis2013symbiotic] or identify all compounds prior to analysis [@whittaker2010songbird] rather than using automated alignment software. Depending on the
sample size and the number of compounds present in the samples, manual alignment can take up to several weeks and might be biased due to subjective expectations of the researcher. 

`GCalignR` provides a simple means of aligning peaks from gas chromatography data based
on retention times. The package also provides ways to visually evaluate the quality of the alignment and allow users to adjust their alignment algorithm parameters to optimize the alignment. The aligned data can easily be used as input
for further widely used statistical packages such as `vegan`. We specifically developed and tested `GCalignR` 
as a preprocessing tool prior to the statistical analysis of chemical samples from animal skin and preen glands [see @stoffel2015chemical for an application of the underlying algorithm]. The implemented algorithm is purely based on retention time data, which is why the quality of the alignment is highly dependent on the quality of the data. `GCalignR` has thus been created for situations when the main interest of the research is about broader patterns rather then the specific function of a certain chemical (which might not be aligned correctly in all samples). 


## Installation

The development version can be downloaded from [GitHub](https://github.com/mastoffel/GCalignR) with
the following code:

```{r, eval = FALSE} 
install.packages("devtools") 
devtools::install_github("mastoffel/GCalignR", build_vignettes = TRUE) 
```

```{r} 
library("GCalignR") 
```

The package provides comprehensive documentation, accessible with

```{r, eval = FALSE} 
?GCalignR 
```

## GCalignR contains the following functions:

* `align_chromatograms`: 
Aligns gas-chromatography peak data by retention times. The core of the package.
* `gc_heatmap`: 
Plots the results (and intermediate steps) of the alignment. A heatmap allows the user to visually
inspect the quality of the alignment to adjust the parameters accordingly if necessary.
* `check_input`: 
Checks the format of the input data for conformity with the requirements and highlights violations.
* `plot.GCalign`: 
Plots the distribution of peaks after the alignment and shows density histograms of applied linear
transformations and retention time ranges (i.e. difference between minimum and maximum retention time per substance).
* `print.GCalign`: 
Summarises the alignment procedure (e.g. documents all arguments to the function call).
* `norm_peaks`: 
Normalises the abundance measure of peaks and returns and data frame of peak concentrations for all samples that is ready to use for analysis tools such as [LINK to veganÂ´s nmds functions]


## The alignment algorithm

The alignment algorithm implemented in the `align_chromatograms` function follows the following steps:
(Here we refer to a peak list as all extracted peaks from a given sample chromatogram)

1. One sample provides a reference peak list, which is used to align all other peak lists
by means of shifting them simultaneously to maximise the number of shared peaks with the reference. This step corrects systematic shifts in the retention times of chromatograms. The maximum shift can be specified with the `max_linear_shift` argument. 

2. After the complete chromatograms are aligned, there will still be variation in the retention time of a substance across samples. The second step corrects this unreliability of individual peak retention times and essentially tries to minimise variation within a retention time row. The maximum shift per peak can be specified with the `max_diff_peak2mean` argument.

3. Inherent to the algorithm, the same substance might have been split apart into two substances across all samples. Therefore, un a third step, retention time rows are merged if they have similar retention time means and non of the samples shows peaks in both rows (with the assumption that these two rows represent a
single substance). The maximum mean difference between two retention time rows can be specified with the
`min_diff_peak2peak` argument. 

### Optional steps:

4. Delete peaks that occur in just one sample by setting the `delete_single_peak` argument to `TRUE`

5. Delete all peaks that occur in control samples or blanks by specifying the IDs of the blank
   samples 


## Input data

The statistical analysis of GC or GC-MS data is usually based on the detection of signal peaks within
chromatograms instead of the full chromatogram. This can be done with proprietary software or free programs such as AMDIS [@stein1999integrated]. The extraction of peaks from chromatograms is based on a certain threshold which might severely influence the quality of the alignment with `GCalignR`. If for instance the peak data includes very small peaks that occured in a very low abundance, the retention time of the peak itself will have a higher poterential error around than very abundant, sharp and therefore high peaks.

The peak data of a chromatogramm usually contain the retention time of a given peak plus additional information such 
as the area under the peak or its height which are used in the subsequent analysis. 
`GCalignR` uses the retention times (and not the mass-spectra, which may not be available, e.g. when 
using gas-chromatography coupled to a flame ionization detector (FID)) to align the peaks across individuals for subsequent chemometric analysis and pattern detection .The simple assumption is that peaks with similar retention times
represent the same substances. However, it is highly recommended to verify this assumption by
comparing also the mass-spectra (if available) of the substances of interest.

## Input file format

The input file for GCalignR is a .txt file, whereby all elements should be separated by tabs (with
sep = "/t") or any other separator, which has to be specified with the `sep` argument (see
`?read.table` for a list of separators) :

* The first row contains the individual IDs, whereby every ID must be unique. IDs should not
contain whitespaces and use the underscore _ as the only special character. 

* The second row
contains the names of the data columns. For example, if you extracted both the retention time of a
peak as well as the area under the peak you would write `RT area` into the second line. You can however
add more variables such as the peak height. 

* Starting with the third row, the actual peak data is included, whereby single samples are concatenated
horizontally. Each chromatogram needs to consist of the same number of columns, whereby at least two are
required, one of which has to contain retention times. (e.g. the retention time and the area).

```{r, out.width = 650, fig.retina = NULL, echo = FALSE}
knitr::include_graphics("example.jpg") 
```

Naturally, not all chromatograms contain the same number of peaks.

```{r, out.width = 650, fig.retina = NULL, echo = FALSE} 
knitr::include_graphics("example2.jpg") 
```

### alternative input from R

Alternative to reading a .txt file, GCalignR also takes input directly from R. Here, `data`
has to be a `list` of `data frames`. Each `list` element (`data frame`) has the ID of an individual
and the `data frame` itself contains the gc-peak data for this individual (again, the minimum
number of columns is one column for the retention time and one column for another variable such as the area under the peak
or it's height). All column names within `data frames` have to be the same.
The attached dataset `peak_data` contains data from skin swabs of Antarctic Fur Seals (*Arctocephalus gazella*) (@stoffel2015chemical)

```{r} 
data("peak_data")
length(peak_data) # number of individuals, i.e. number of list elements
names(peak_data) # names of individuals, i.e. names of list elements 
head(peak_data[[1]]) # column names and data, i.e. one data.frame of list element 
```

## GCalignR workflow

### Check the input

To check the data formatting for the most common errors, use the `check_input` function. This will test for conformity with the requirements of the aligning algorithm. Common error sources such as missing data or missing sample names are eliminated as well as unconsistencies among samples (if the input is a list of samples). Error messages will indicate any violation. When a .txt file is used as input, the decimal has to be a point (not a comma). 

```{r}
check_input(data = peak_data,list_peaks = F) # If list_peaks = T, a histogram of peaks is plotted 
```

### Align Chromatograms

The core function in `GCalignR` is `align_chromatograms`, which will align the peak lists 
with the algorithm descript above. See `?align_chromatograms` for a detailed description of the arguments.

```{r, eval = FALSE}
peak_data <- peak_data[1:4] # subset for speed reasons
peak_data_aligned <- align_chromatograms(data = peak_data, # input data
    conc_col_name = "area", # peak abundance variable
    rt_col_name = "time", # retention time 
    rt_cutoff_low = 5, # cut peaks with retention times below 5 Minutes
    rt_cutoff_high = 45, # cut peaks with retention times above 45 Minutes
    reference = NULL, # Reference will be choosen automatically 
    max_linear_shift = 0.05, # maximum linear shift of chromatograms
    max_diff_peak2mean = 0.03, # maximum distance of a peak to the mean
    min_diff_peak2peak = 0.03, # maximum distance between the mean of two peaks
    blanks = "C2", # no blanks. Specify blanks by names (e.g. c("blank1", "blank2"))
    delete_single_peak = TRUE, # delete peaks that are present in just one sample 
    write_output = NULL) # add c("time","area") to write data frames to .txt file
```

The aligned data is now stored in a `data.frame` which can be accessed as follows. 

```{r, eval = FALSE}
peak_data_aligned$aligned$time # to access the aligned retention times
peak_data_aligned$aligned$area # to access the aligned area data
```

```{r}
data("aligned_peak_data") # the package includes the already aligned data set  
``` 

### Visual diagnostics for the aligned data

The `gc_heatmap` function can be used to visualise the quality of the alignment. A white filling indicates the absence of a peak in a sample, when using the default option of a binary heatmap. The basic rationale of the alignment was to sort the substances with very similar retention times together, as they most likely represent one substance. The heatmap show how the single peaks for the individuals deviate from the mean retention time of a substance. The larger the deviation, the less likely it is the same substance. However, going back to the original chromatograms and looking at the quality of the peak might help. In the following example, the alignment was fairly good and no substance deviated by more than 0.05 seconds 

```{r,message=FALSE,fig.width=8,fig.height=8}
gc_heatmap(aligned_peak_data,threshold = 0.05) # By default a threshold of 0.05 is used to mark deviations
```


```{r,message=FALSE,fig.width=8,fig.height=8}
plot(aligned_peak_data) # Three Diagnostics, can be invoked separetely
```

```{r, eval=FALSE}
print(aligned_peak_data) # Summary of the alignment procedure
```
### Normalise peaks and log+1 transformation

`norm_peaks` is used to standardize the concentration of peaks across samples to obtain the relative abundance. This is an essential step prior to the analysis if the absolute concentration chemical samples varies across individuals. Note that this step is required when retention time cutoffs, single peak deletion or blank peak removal was applied, even if the data already contained a measure of relative abundance.
The output is a list of data frames containing the relative abundance of peaks for every individual.

```{r}
scent <- norm_peaks(aligned_peak_data, conc_col_name = "area",rt_col_name = "time",out = "data.frame") # normalise area and return a data frame
scent <- log(scent+1) # commonly used transformation for abundance data to reduce the extent of mean-variance trends
```


### Visualise patterns by ordination plots using the *vegan* package

`vegan` offers a variety of useful function for the analysis of multivariate abundance data such as the scent profiles handled here. Check out *?vegan* for a first overview. 

### Non-metric multidimensional scaling 
```{r,fig.align="center",fig.cap="NMDS-Plot"}
library(vegan)
data("peak_factors") # factors for individual scent samples
scent <- scent[match(row.names(peak_factors),row.names(scent)),] # bring both to the same order
scent_nmds <- vegan::metaMDS(comm = scent) # performs Nonmetric multidimensional scaling (NMDS)
scent_nmds <- as.data.frame(scent_nmds$points) # get the xy coordinates for every individual 
scent_nmds <- cbind(scent_nmds,colony=peak_factors$colony) # add the colony as a factor 
ggplot2::ggplot(data = scent_nmds,ggplot2::aes(MDS1,MDS2,color=colony)) +
    ggplot2::geom_point(size=4) + ggplot2::stat_ellipse(size=2) + ggplot2::labs(title ="", x = "MDS1", y = "MDS2") + ggplot2::theme_void()
```

### Multivariate analysis using *adonis*
Using **adonis** and **betadisper** we can immediately do multivariate statistics, showing that the two colonies differ significantly. This illustrates a location effect.
```{r}
vegan::adonis(scent ~ peak_factors$colony,permutations = 999) # Colonies differ in the location
anova(vegan::betadisper(vegan::vegdist(scent),peak_factors$colony)) # No dispersion effect
```

## Literature
