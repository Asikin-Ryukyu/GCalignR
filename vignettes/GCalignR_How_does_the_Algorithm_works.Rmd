---
title: "GCalignR: How does the Algorithm works?"
author: "Meinolf Ottensmann, Martin A. Stoffel, Hazel Nichols and Joseph I. Hoffman"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: bibliography.bib
vignette: >
    %\VignetteIndexEntry{GCalignR How does the Algorithms works?}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---
 
```{r, echo = FALSE}
library(knitr)
knitr::opts_chunk$set(collapse = TRUE, comment = ">", cache = FALSE,
    fig.width = 8, fig.height = 6, fig.align = "center") 
```

```{r, results='hide', echo=FALSE}
library(GCalignR)
library(ggplot2)
```

## Preface
The intention of this vignette is to illustrate how the algorithms in `GCalignR` handle the data during each of the processing steps. Simultaneously we deploy some simple datasets that can be generated within R to visualise the outcome of the processing steps in an easy way. For the fairly simple math behind the algorithm we refer to our manuscript that is available as a preprint [@Ottensmann.2017]. 
Here, we give a detailed introduction into the concept behind the package and illustrate how it works by simulating simple datasets with arbitrary peaks. To enhance readability, not all code lines are show within this vignette, but they can be easily accessed by typing `browseVignettes("GCalignR")` and clicking on `R code`. The datasets are pseudo-randomly created and can therefore differ from run to run. For consistency, we supply the dataset that is used to demonstrate the alignment progress with the package. An accompanying vignette `GCalignR: Step by step` focuses on the workflow with this package and the integration into a broader analysis pipeline. 

## WhatÂ´s a Peak List and how to create one ?
`GCalignR` performs all steps on a so called *peak list*. Such a list can be generated for every chromatogram, defined as the output of a Chromatograph (e.g. **G**as **C**hromatography **F**lame **I**onization **D**etector, GC-FID) that plots the measured electric current over the time course of a separation run. Figure 1 shows a chromatogram containing five peaks that represent five chemicals detected in this simulated sample. Here, all the distinct peaks approximate perfect Gaussian distributions and are clearly separated.
Essentially every vendor of a Chromatograph offers software that allow to detect peaks (i.e. compounds) in the generated signal based on procedures that take into account the shape of a peak, the noise level of the signal and many things more that are out of the scope of `GCalignR` and we refer to specialised resources [@Grob.2004]. Nevertheless, the quality of the chromatograms as well as a sophisticated way to detect and quantify peaks is a crucial step before one should start to think about aligning peaks for downstream analysis!

```{r, fig.cap="Figure 1. A Chromatogram plots an intensity signal over the course of a separation run.", echo=F}
set.seed(123)
# create one chromatogram with specified peaks
df1 <- GCalignR:::simple_chroma(peaks = c(5.01,10.02,13.10,20.22,24.57), N = 1)
# plot the chromatogram
chroma <- ggplot(data = df1, aes(x,y, fill = sample)) + geom_line(size = 1) + theme_classic() + xlab("Retention time ") + ylab("Intensity") + scale_x_continuous(breaks = seq(0,30,1),expand = c(0,0)) + theme(axis.text.y = element_blank(), axis.ticks.y = element_blank()) 
chroma
```

In this example it would be adequate to define each peak by two values, the retention time and the peak height as a measure of the concentration, simply by calculating the local maxima. Figure 2 shows the peaks annotated by the intensity. The dashed vertical lines indicate the retention time of the peaks maximum that is written on top of each of the five peaks.

```{r, echo=F, fig.cap="Figure 2. Chromatogram with integrated peaks"}
# Using an internal function, peaks are detected by searching for global maxima
peaks <- find_peaks(df1) 
# create the plot
chroma + geom_linerange(data = peaks, aes(x = x, ymin = 0, ymax = y), linetype = "dashed", col = "Darkblue") + annotate("text", x = peaks[["x"]], y = peaks[["y"]] + 0.1, label = as.character(round(peaks[["y"]],2)), angle = 0) + geom_area(fill = "blue", alpha = 0.4) + theme(legend.position = "none")
```
Now these and further information (e.g. the peak area) can be summarised in the form of a peak list that contains information for every detected peak. One row of such a peak list refers to a single peak. In general, peaks are ordered with increasing retention time, thereby starting with the most volatile substances. 

```{r, echo=FALSE}
# create a data frame that depicts a peak list
df <- data.frame(row.names = c("Peak 1", "Peak 2", "Peak 3", "Peak 4", "Peak 5"), time = peaks[["x"]], height = peaks[["y"]])
# print the table
knitr::kable(df,digits = 2)
```

Figure 3 shows chromatograms of four samples "A1" to "A4" that were analysed on the same fictive GC-FID run. These peaks can be individually characterised by their retention times (see labels on each peak). In this small set of samples, one can easily see that several peaks appear in consistent temporal sequence with increasing retention times in sample order approximating intervals of 0.7 minutes. Here, it would be possible to account for this variation manually, but consider a scenario where there are many more samples and peaks, perhaps in noisier chromatograms.
For this reason we developed `GCalignR` and implemented simple algorithms that are explained below. Before these chromatograms can be analysed, we need to obtain peak retention times and peak heights again. Additionally we need to format it for using `GCalignR` to align the peaks. `GCalignR` is distributed with sample files that can be used as templates.

```{r, results='hide', echo = FALSE, fig.cap="Figure 3. Overlay of Chromatograms from four samples"}
set.seed(123)
peak_list <- sample(x = seq(from = 1, to = 26, by = 4), size = 6, replace = F)
df <- GCalignR:::simple_chroma(peaks = peak_list, N = 4)
# draw chromatograms and display peaks
chroma <- ggplot(data = df, aes(x,y, col = sample)) + geom_line(size = 1) + theme_classic() + xlab("Retention time ") + ylab("Intensity") + scale_x_continuous(breaks = seq(0,30,5),expand = c(0,0)) + theme(axis.text.y = element_blank(), axis.ticks.y = element_blank(), legend.position = "bottom") + scale_color_brewer(palette = "Dark2") + guides(col = guide_legend(ncol = 4, title = NULL))

# peaks are in this case simply the local maxima for each sample
peaks <- find_peaks(df)
chroma <- chroma + geom_linerange(data = peaks, aes(x = x, ymin = y, ymax = y + 0.1), linetype = "solid", col = "black") + annotate("text", x = peaks[["x"]], y = peaks[["y"]] + 0.2, label = as.character(round(peaks[["x"]],2)), angle = 90)
print(chroma)
```
The standard input format is a tab-delimited text file that contains all the required information.(1) The first row lists the sample identifiers of all the samples included for aligning, (2) column names are written in the second row and specify the content of individual peak lists that are (3) incorporated for each individual below. Peak lists have to be concatenated column-wise in the order specified in the first row. The input file belonging to the chromatograms shown in Figure 3 is depicted below. Several sample files are distributed with `GCalignR`. Type `system.file("extdata", package = "GCalignR")` to obtain the path on your computer. 

```{r, echo = FALSE, results='hide', eval=FALSE}
## these lines create a input file which is distributed with the package 
# sink("ChromSimul.txt",append = FALSE)
## write sample identifier
#cat(levels(peaks[["sample"]]),sep = "\t")
## write variables
#cat(c("\nrt","height\n"),sep = "\t")
## merge data horizontally

#dat_mat <- numeric()

#for (i in levels(peaks[["sample"]])) {
 #   temp <- as.matrix(peaks[,c("x","y")][peaks[["sample"]] == i,])
  #  add <-  max(summary(peaks[["sample"]])) - nrow(temp)
   # temp <- rbind(temp, matrix(data = 0,nrow = add, ncol = 2))
    #  dat_mat <- cbind(dat_mat, temp)
#} 
#write.table(dat_mat, row.names = F, col.names = F, sep = "\t")
#sink()
```

```{r, echo = FALSE}
## sample identifiers
cat(levels(peaks[["sample"]]),sep = "\t") 
## variable names
cat(c("\nrt","height\n"),sep = "\t") 

## empty matrix to fill with the data
dat_mat <- numeric()
for (i in levels(peaks[["sample"]])) {
    temp <- as.matrix(peaks[,c("x","y")][peaks[["sample"]] == i,])
    add <-  max(summary(peaks[["sample"]])) - nrow(temp)
    temp <- rbind(temp, matrix(data = 0,nrow = add, ncol = 2))
    dat_mat <- cbind(dat_mat, temp)
} 
## output the formatted matrix
write.table(dat_mat, row.names = F, col.names = F, sep = "\t")
```


## Aligning peak lists
Over the course of the analytic pipeline, retention times of the same substance can vary for a number of reasons that include column ageing, perturbations of the carrier gas flow or temperature fluctuations, all of which can be avoided with varying success. `GCalignR` comes into place, when a question regarding the similarity of a number of samples is addressed by analysing their chemical composition. For this purpose it is crucial to cluster peaks that belong to the same substance across samples. 
All alignment steps take only the retention time of a peak into account and are embedded within a single function `align\_chromatograms` that conducts the alignment sequentially. Any other variable included in the dataset remains always associated with the retention time of the peak and is not treated any further. The single steps undertaken by the function to align the data can be traced back from the output that is returned after execution of `align\_chromatograms`.

### Linear Drift
The first step in the alignment acts on linear drifts across samples. Therefore, a reference sample is required that should be selected manually based on criteria listed below. Otherwise a reference will be selected automatically. A suitable reference would be a sample that is *a priori* expected to be similar to all other samples by sharing a proportion of substances. Is advisable to analyse at least one sample under identical conditions with two-dimensional techniques (e.g. GC-MS) and use this as a reference in order to obtain valuable information on the chemical composition behind some of the peaks. Linear shifts between each sample and the reference are evaluated in a pair-wise comparison similar to a cross-correlation based on the peak retention time alone. Thereby, the sample is slided in a user-defined window in discrete time steps.
Figure 4 illustrates this for one pair-wise comparison of two chromatograms, where the linear drift was adjusted accordingly.
Here, the "true" linear shift between reference and sample is approximated by detecting the maximum number of shared peaks in response to the applied shifts. Peaks are counted as shared when their retention times matches within a error margin given by `max_diff_peak2mean`. Whenever more than one shift size (including 0!) yield to the same number of shared peaks, the smallest value is taken to avoid overshooting.

```{r, echo=FALSE, fig.cap="Figure 4. Corrected linear drift between reference and sample"}
# graphical representation of the procedure that is applied during the correction of linear drift.
set.seed(1533)
# create two samples
df <- rbind(simple_chroma(peaks = c(10,15,22), N = 1, Names = "Reference"), simple_chroma(peaks = c(12,16.89,24), N = 1, Names = "Sample"))
peaks <- find_peaks(df)
peaks2 <- peaks
# Adjust retention times to shift the sample chromatogram
peaks2[["x"]] <- peaks2[["x"]] - 2
peaks2[["x"]][peaks2[["x"]] < 0] <- 0

# create a data frame for plotting
df2 <- data.frame(x = rep(seq(0,30,length = 10000),2), y = c(GCalignR:::peaks2chroma(data = peaks, sample = "Reference"), GCalignR:::peaks2chroma(data = peaks, sample = "Sample")), sample = rep(c("Reference", "Sample A"), each = 10000), y2 = c(rep(0, 10000),GCalignR:::peaks2chroma(data = peaks2, sample = "Sample")))

#subset on x
df2 <- subset(df2, df2$x > (min(peaks[["x"]]) - 1) & df$x < (max(peaks[["x"]]) + 1))

# plot
plot <- ggplot(df2, aes(x = x, y = y, col = sample, fill = sample)) +
    geom_line(size = 1.2) +
    theme_classic() + xlab("Retention time ") + ylab("Intensity") +
    scale_x_continuous(expand = c(0,0)) +
    theme(axis.text = element_blank(), axis.ticks = element_blank(), legend.position = "bottom") +
    geom_line(aes(x = x,y = y2), linetype = "dotted", size = 1) +
    scale_color_manual(values = c("black","black"), guide = FALSE) +
    geom_area() +
    scale_fill_manual(values = c("darkorange","blue"), name = "") +
    geom_area(aes(x = x,y = y2), alpha = 0.6) +
    geom_segment(aes(x = peaks[peaks[["sample"]] == "Sample",][2,1], xend = peaks2[peaks2[["sample"]] == "Sample",][2,1], y = find_peaks(df2)[5,2] + 0.05, yend = find_peaks(df2)[5,2] + 0.05),size = 1.2, colour = "black", arrow = arrow(length = unit(x = 0.14, units = "cm"))) +
    annotate("text", x = find_peaks(df2)[5,1] - 1, y = find_peaks(df2)[5,2] + 0.25, label = "Linear shift", angle = 0) + xlab(label = "") + ylab(label = "") 
print(plot)
```

Now we are going to apply the alignment to a dataset that is highly similar to the example depicted in Figure 3. Here, all peaks are shown with the same shape, which is appropriate as we are only interested in the retention times.  
Based on the inspection of the graph shown in Figure 5, we pick "A2" as a reference and take into account that peaks of "A3" and "A4" are seemingly postponed by approx. 0.7 and 1.4 minutes, whereas "A1" shows peaks 0.7 minutes earlier. Therefore, a good estimate for the required window size to correct for linear shifts is given by `max\_linear\_shift = 2` yielding to a window of 2 Minutes around the retention times of the reference sample.

```{r, fig.cap="Figure 5. Chromatographic representation of the dataset prior to alignment"}
## path to the data
path <- system.file("extdata", "simulated_peak_data.txt", package = "GCalignR")
## draw chromatograms
x <- draw_chromatogram(data = path, rt_col_name = "rt", show_rt = T, show_num = F, plot = F)
x[["ggplot"]] + geom_line(size = 1.2) + theme(axis.ticks.x = element_blank())
```

```{r, eval=T, results="hide"}
aligned <- align_chromatograms(data = path,
                               rt_col_name = "rt",
                               max_linear_shift = 2,
                               max_diff_peak2mean = 0.02,
                               min_diff_peak2peak = 1,
                               reference = "A2")
```

`GCalignR` creates a *Logfile* while processing a dataset that allows to trace back the Linear shifts that have been applied to the samples. We can see that the linear shifts of "A3" and "A4" are of the size that we expected, whereas the drift in "A1" was putatively not fully compensated with 0.5 instead of 0.7.

```{r}
print(aligned[["Logfile"]][["LinearShift"]])
```
Using `draw_chromatograms` again, we can inspect how the linear corrections have changed the peak list.
```{r, results="hide"}
x <- draw_chromatogram(data = aligned, rt_col_name = "rt", step = "lin_aligned", show_rt = F, show_num = F)
```
We immediately see that the peaks were shifted accordingly and start to cluster as expected. However, there is variation in retention times among the samples within the visually separated clusters. Therefore, we utilise another algorithm that evaluates the observed variance and decides which peaks belong to the same substance. These steps were already executed with the call to `align_chromatograms` and we can inspect the results by simply changing including `step = "fully_aligned"`. This time we also set `show_num = T` in order to print the number of samples *behin* each peak. This is helpful, because peaks of the same substance will overlap. 

```{r, results="hide"}
x <- draw_chromatogram(data = aligned, rt_col_name = "rt", step = "fully_aligned", show_num = T)
```
We can test that not only "A4" contributes to the peaks by moving each sample to own panels of the plot.

```{r}
## for using ggplot2::facet_wrap we need to get rid of the annotations
x <- draw_chromatogram(data = aligned, rt_col_name = "rt", step = "fully_aligned", show_num = F, plot = F)
x[["ggplot"]] + ggplot2::facet_wrap(~sample, ncol = 1)
```

## Remarks
The dataset that was used for this vignette was created by picking peaks pseudo-randomly and adding arbitrary perturbations. Especially the amplitude of linear drift in the range of minutes is not expected in *real life* application of chromatography and was used to illustrate the principles. When one works with experimental data we suggest to use the original chromatograms in combination with the `draw_chromatogram` tool to explore the data carefully, for example by looking at subsets of samples and different time scales.

## References
